\chapter{Fazit}
Abschließend zu der Arbeit werden Probleme benannt, die während des Prozesses aufgekommen sind. Außerdem wird zusammengefasst, was erreicht wurde, was eventuell versäumt wurde und welche Möglichkeiten sich in der Zukunft durch diese Kontribution für das MoDiGen Projekt ergeben.
\section{Probleme}
Die Arbeit war sehr zeitaufwendig, da die bestehende Objektstruktur, die durch die Xtext Grammatik beschrieben wurde auf Scala bezogen gelegentlich keinen oder wenig Sinn machte. Hin und wieder wurden auch Fehler in der definierten DSL entdeckt. 
Da das Umsetzen einer DSL in Scala ausgehend von einer Xtext Grammatik voraussetzt, dass entsprechende Grammatik verstanden wurde, dauerte es außerdem eine Weile, bis alle Unklarheiten bezüglich der Grammatik beseitigt wurden. Hin und wieder machten sich Fehler erst lange Zeit später bemerkbar, so mussten hin und wieder bestehende Klassen komplett neu überarbeitet werden. Auch Xtext Sprachkenntnisse waren nötig, da z.B. die Generatoren der Xtext Sprache sonst unklar erscheinen.
Methodenaufrufe wie createColorValue, die wie in \ref{specialstyle} beschrieben worden sind, sind ähnlich den \textit{implicits} in Scala für Neulinge absolut unverständlich. Auch bis die Xtext Quelldateien richtig interpretiert werden konnten, verging einige Zeit.
Da das benötigte Metamodell zur Zeit der Entwicklung noch nicht einsatzbereit war, musste sich an einigen Stellen mit Mockups geholfen werden.
\subsection{Scalaspezifische Probleme}
Scalaspezifische Probleme gab es tatsächlich nicht viele. Scala ist einfach zu erlernen, bietet komfortable Collections, sowie eine ausgezeichnete und einheitliche Collections API. Außerdem bietet Scala Features wie \textit{case classes} und \textit{Pattern Matching}, um nur ein paar zu nennen. Diese Features sind schnell verstanden und umsetzbar. Einzig und allein die Tatsache, dass hier ein Scala Neuling am Werk war, bremste die Arbeit erheblich aus. So wurde zunächst mit langen und sehr komplexen regulären Ausdrücken versucht, beliebige Shapedefinitionen zu parsen, was aber aufgrund der Rekursion der in sich geschachtelten geometrischen Figuren unmöglich ist. Ein Scala Kenner, hätte sofort zu den \textit{Parser Combinator} Klassen gegriffen, diese waren dem Autor zunächst aber noch nicht bekannt. Scala bietet viele Lösungen für viele Probleme, jedoch ist es insbesondere als Scala Neuling zunächst ein Labyrinth aus Möglichkeiten und oft wird erst später bemerkt, dass eine alternative Lösung besser passt. Ein tatsächlicher Nachteil von Scala gegenüber der Xtext Technik findet sich in der Implementierung der Generatorenklassen wieder. Xtext bietet für die Definition auszugebender Strings Makros an, welche es ermöglichen Kontrollstrukturen wie if-Bedingungen und Schleifen reibungslos in String Definitionen einzubringen. Scala verfügt zwar über einen ähnlich mächtiges Feature namens \textit{String Interpolation}, jedoch hat dies einen entscheidenden Nachteil: Scope. Strings wie in Listing \ref{lst:xtextstring},
\begin{lstlisting}[style = scala, literate={«}{{\flqq}}1 {»}{{\frqq}}1, caption = {String der in Xtext über Makros sauber formatiert erstellt werden kann}, label = {lst:xtextstring}]
"""
Stencil.groups = {
	«var i = 0»  
	«val groupSet = getNodeToPaletteMapping(diagram).keySet()»  
	«FOR group : groupSet»  
		«getVarName(group)»  : {index: «i=i+1»  , label: '«group»  ' }«IF group != groupSet.last»  ,«ENDIF»  
 	«ENDFOR»  
};
"""
\end{lstlisting}
sind schon während sie entstehen so formatiert, wie ihr späterer Output. Das entsprechende Pendant in Scala ist in Listing \ref{lst:scalastring} zu sehen.
\begin{lstlisting}[style = scala, caption = {String der in Scala über Interpolation modifiziert wird}, label = {lst:scalastring}]
var i = 0
var group = ""
val groupSet = getNodeToPaletteMapping(diagram).keySet
s"""
Stencil.groups = {
	${for (groupName <- groupSet) yield {
		group = groupName
		getVarName(group)
	}
}: {index: ${i = i + 1}, label: '$group' }${if (group != groupSet.last) s","}
};
"""
\end{lstlisting}Scala bietet es zwar an über \textit{Escaping} \textit{\$\{\}} Codeblöcke innerhalb von Strings auszuführen, jedoch eröffnen diese Codeblöcke auch einen eigenen Scope. Zählvariablen (beispielsweise) müssen in diesem Fall im überliegenden Scope definiert werden um alle seperaten Code Blöcke im String beeinflussen zu können. Die entstandene Formatierung ist insgesamt nicht so gut wie die, die durch die Xtext Makros zu erreichen ist. Das ist tatsächlich nur ein kleines Ärgernis, aber der Vollständigkeit halber aufzuführen.

\section{Schlussfolgerung/Ausblick}
\subsection{Was wurde erreicht}
Die Objektstruktur wurde erfolgreich in Scala umgesetzt. Hierbei wurde darauf geachtet, dass alle Modellklassen immutabel sind. In Zukunft kann so auf funktionale Programmiertechniken zurückgegriffen und insbesondere paralleler Code effizient genutzt werden. Die DSLs zu Style, Shape, Connection und Diagram können erfolgreich eingelesen und übersetzt werden. Hierbei wurde darauf geachtet, dass eine erste Parserlogik (\textit{Lexer}) die eingelesenen Strings in einheitliche Datenformate umwandelt, sodass spezialisiertere Parser ihren Input einheitlich behandeln können. So ist der Parser relativ leicht zu erweitern. Mehrfachvererbung bei Styles war mit Scala problemlos umsetzbar. Das iterieren über Elternelemente ist mittels generischer \textit{Getter Funktionen} unwahrscheinlich einfach. Auch die (Mehrfach-) Vererbung bei Shapes funktioniert. Die Objektstruktur lässt sich also definitiv flexibler gestalten als in Xtext. Style Eigenschaften werden transitiv an unterliegende Elemente weitergegeben, wobei die hierdurch entstehenden Abhängigkeiten aus Anwendersicht statisch gebunden werden. Außerdem können abstrakte Shapes definiert werden, die ohne ein Diagram erzeugt werden können um so allgemeine Eigenschaften einer logischen Gruppe zu bündeln. Geerbte Informationen werden prinzipiell zum Erzeugungszeitpunkt an Kindelemente weitergegeben. Somit ist die Anwendung besonders bei großen Baumstrukturen der Modellklassen nicht darauf angewiesen (eventuell auch mehrere male) Styleattribute über rekursive Methoden zu finden. 
\subsection{Was nicht erreicht wurde}
Da zu Anfang entschieden wurde die Vergabe transitiver Style Eigenschaften schon bei Objekterzeugung weiterzugeben, musste später festgestellt werden, dass aufgrund der Instantiierungsreihenfolge Containerklassen notwendig sind, welche es erlauben die Erzeugung einer Modellklasse auf einen späteren Zeitpunkt zu verschieben. Dies erzeugt einen zusätzlichen Overhead an Speicherbedarf. Alle erzeugten Objekte von Modellklassen werden in einem Cache hinterlegt um zu ermöglichen sie über ihren Namen mittels eines Mappings zu referenzieren. Auch die Skizzen, also die Containerklassen, der Modellklassen müssen in diesem Cache hinterlegt werden, um fortlaufend bei Bedarf erzeugt werden zu können. So können also die Containerklassen auch nicht nach Erzeugung einer zugehörigen Modellklasse gelöscht werden. Performanz für Speicherauslastung.
Über die Anwendung \textit{VisualVM} \Myciten{jvisualvm}{404-405} lässt sich ein \textit{Heapdump} erstellen und analysieren. Beispielhaft wurden hierfür 10.000 Shapes eingelesen, um anschließend über VisualVM betrachtet werden zu können (siehe Abbildung \ref{jvisualvm}).
\begin{figure}[h]
	\begin{center}
		\includegraphics[width=\textwidth]{Bilder/10000shapes.png}
		\caption{Ausschnitt aus dem Heapdump, generiert durch JVisualVM}
		\label{jvisualvm}
	\end{center}
\end{figure}Ersichtlich wird, dass bei 10000 Shapes auch 10000 ShapeSketches erzeugt werden. Das ist der angesprochene zusätzliche Overhead.
Generell kann festgestellt werden, dass über die Lösung in Scala Funktionalität mit eingebracht werden konnte, die Xtext nicht bietet, jedoch bietet Xtext Vorteile die hier nicht verfolgt wurden, wie die Konsistenz zwischen DSL und Objektstruktur. Ändert sich in diesem Projekt die DSL oder die Objektstruktur, muss von Hand dafür gesorgt werden, dass Parser und Modellklassen konsistent bleiben. Das liegt daran, dass die DSL nur implizit über die Parser Regeln definiert ist.
\subsection{Ausblick}
Nächste Schritte für das Programm könnten sein, eine Scala Bibliothek zu erstellen, die eine DSL zur Beschreibung von Grammatiken anbietet. Das hört sich erst einmal verwirrend an. Derzeit wird über eine vordefinierte Grammatik eine (beispielsweise) Shape beschrieben und über einen Parser in ein bereits vordefiniertes Objekt umgewandelt. Da die Shape Klasse also wie gesagt schon vordefiniert ist besteht ein Konsistenzproblem zwischen DSL und Objektstruktur. Wird die Grammatik zur Beschreibung der Shape verändert, muss die Shape Klasse ebenfalls von Hand verändert werden um eine korrekte Abbildung zu garantieren. Würde eine DSL benutzt werden, die es erlaubt Grammatiken zu erstellen, könnten die bisher vordefinierten Klassen Style, Shape, Diagram über Generatoren aus der durch die DSL erstellte Grammatik erzeugt werden. So wäre eine konsistente Lösung geschaffen. Man müsste nicht sowohl Parserregeln als auch die Modellklassen verändern, sondern würde dies implizit tun, indem man die Definition der Modellklassen über die DSL verändert. Diese Vorgehensweise wird so in etwa auch von Xtext realisiert. Fraglich wäre also, ob dies so problemlos möglich ist, oder ob Features wie Mehrfachvererbung unter diesem Ansatz leiden könnten, immerhin ist dies so in Xtext nicht möglich. Des weiteren könnten Parsingvorgänge parallelisiert werden. Das würde die Performanz deutlich steigern und müsste auf Grund der immutablen Klassen auch einfach und ohne komplexe Synchronisationsmechanismen umsetzbar sein. Zusätzlich könnte überlegt werden, ob im Bezug auf die Vererbungsstrategie lediglich für Style Instanzen eine Ausnahme gemacht wird. Styles würden also nicht wie jetzt bei Objekterzeugung sondern erst, wenn Attribute abgefragt werden von den Eltern ermittelt werden. Wie bereits gesagt muss hier unterschieden werden, ob schlussendlich mehrfaches rekursives Suchen und optimale Speicherauslastung oder eine nicht rekursive Problemstellung und ein damit einher gehender Overhead an Containerelementen bevorzugt werden. Vererbungsprinzipien sind nun gegeben und können falls gewünscht einfach auf Connection und Diagram übertragen werden. So könnten auch Connections und Diagrams von Elternelementen erben. 