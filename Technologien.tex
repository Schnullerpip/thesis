\chapter{Grundlagen: Scala/Xtext}
\section{Scala}
Im folgenden soll zum Verständnis zunächst die Programmiersprache \textit{Scala} vorgestellt werden.
Die Entwicklung von \textit{Scala} (Scalable Language) begann bereits 2001 an der\textit{ École polytechnique fédérale de Lausanne} in der Schweiz durch ein Team um Professor \textit{Martin Odersky}(vgl. \Myciten{braun:scala}{1}). Designziel war eine elegante, typsichere Programmierung, vollkommene Kompatibilität mit der \textit{JVM} und eine Zusammenführung der Objektorientierung und der funktionalen Programmierung (vgl. \Myciten{braun:scala}{2}). Scala ist hierbei objektorientierter als z.B. Java, da in Scala \textit{alles} ein Objekt ist. Odersky selber bezeichnet Scala als postfunktionale Sprache (vgl. \Myciten{braun:scala}{2}), da immer noch diskutiert wird, ob Scala als funktionale Programmiersprache betitelt werden darf. Fest steht jedoch, dass man in Scala funktional programmieren kann - man muss es allerdings nicht. Funktionen können Argumente oder Ergebnisse anderer Funktionen sein und sind somit \textit{Higher Order Functions}. Trotz der Typsicherheit bietet Scala das \textit{Feeling} einer dynamisch typisierten Sprache, da Typen beim Kompilieren inferiert werden können. Der \textit{Compiler} erkennt also anhand des initialisierten Wertes, um was für einen Typ es sich handelt, so kann fast immer auf manuelle Typkennzeichnung verzichtet werden.
\begin{lstlisting}[style = scala, caption = {Beispielhafte Varablendefinition mit Typinferierung und manueller Typangabe}, label = {lst:typeinferation}]
var name = "Julian"
var alter = 24
var nachname:String = "Müller"
var matriklnummer:Int = 287501
\end{lstlisting}
Die Variablendefinitionen \textit{name} und \textit{alter} aus Listing \ref{lst:typeinferation} sind vollkommen korrekte Ausdrücke und werden ebenso kompiliert wie \textit{nachname} und \textit{matrikelnummer}.
Scala ist einfacher zu erlernen, als beispielsweise Java, da Anweisungen auch alleinstehend als Skript oder direkt in einem interaktiven Scala Interpreter ausgeführt und ausprobiert werden können. 
Komplexe Problemstellungen können stark abstrahiert in wenigen Zeilen Code beschrieben werden, da Funktionen Objekte sind und als Parameter übergeben werden können. Über entsprechende Methoden, kann man sogar eigene Operatoren und Kontrollstrukturen erstellen. Übrigens: \textit{"`Damit ist Scala prädestiniert zur Erstellung von Domain Specific Languages $[$...$]$"'}(\Myciten{braun:scala}{2}).
\section{Xtext}\label{xtext}
Nachdem nun Scala erörtert wurde, soll im folgenden die zu ersetzende Technologie \textit{Xtext} beschrieben werden.
"'\textit{Xtext ist ein quelloffenes \textit{Eclipse Framework} zum Implementieren von domänen spezifischen Sprachen [...]}"'\Myciten{bettini:xtext}{13}.
Xtext ist ein Framework mit dem u.a. domänenspezifische Sprachen entwickelt werden können und ergänzt das \textit{Eclipse-Modeling-Framework}. Dafür wird eine komplexe Grammatiksprache zur Vergügung gestellt, über die Entitäten deklariert und assoziiert werden können. Anhand der Grammatik erzeugt Xtext Parser, Generatoren und sogar ein Klassenmodell für die beschriebenen Klassen. Um die beschriebene DSL ausführbar zu machen wird außerdem ein Texteditor generiert, welcher entsprechendes \textit{Syntax Highlighting} automatisch programmiert. Der große Vorteil von Xtext ist, dass die Definition der beschriebenen Sprache gleichzeitig die Objektstruktur der zu generierenden Modelle beschreibt. Wird die DSL verändert, ändert sich die Objektstruktur der Modelle ebenfalls und so bleibt die Abbildung von DSL auf Modell immer konsistent. 
